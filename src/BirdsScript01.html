<!DOCTYPE html>
<html lang="ja">
<!--
つい、カッ！となってLL言語を作りはじめてしまいました。名前は「BirdsScript」です。
（2014/07/28 現在、未完成。JavaScriptによる試作中。）

Source Layout
=============

プロジェクトには、以下のファイルが含まれます。

    README.md             このファイル
    src/                  ソースコード
    src/BirdsScript.html  HTMLによるコンパイラ(Yamasemi)＆実行系(Kawasemi)の呼び出しとテスト。それから仕様メモ。
    src/Kawasemi.mini.js  Javascriptによる実行系の試作。
    src/Yamasemi.mini.js  Javascriptによるコンパイラの試作。

特徴：
--------

「軽くて小さいから、素早く高く遠くへ飛べる」

すべてのプログラマーのために「軽量で」「安全で」「大規模開発に耐えられる」「使って楽しい」言語を目指してみました。
（C/C++ や JavaScript に近い言語だと勝手に思っています）

list と名づけた、なんでも入る「便利な配列」が言語の仕様として入っている点が１つの特徴かも。
また、関数の戻り値は常にlist ですし、loopやeachなどの繰り返し文もlist を戻り値として返します。この点は他の言語にはみられない特長になると思っています。


「軽量で」
--------

  ・記述量が軽量（ var とか function とか class とか private とか public とか書く必要はありません。型名も int とか string とか （いまのところ）ほとんんど記述する必要がない。）

  ・文法も軽量。予約語も少ない。（ for, each, switch, case, などの予約語は存在せず、代替の記述方法があります）

  ・実装も軽量。いまのところコンパイラ(Yamasemi)も、実行系(Kawasemi)も、JavaScriptで1000行程度。（最終的にはC/C++で4000行程度になるはず）

「安全で」
--------

  ・定数宣言を重視（不必要な変数はバグの元となると考えて（関数型言語を見習って））

  ・空の変数は存在できない（変数の値が未定という状態は無い）

  ・カプセル化がデフォルト。メンバは private になる（デフォルトで隠蔽され、外部からのアクセス可能にするには手間（'.'の記述）が必要）

  ・参照領域がブロックスコープで区切られていて必ず解放される（不要になった変数が参照できてしまうのはバグを埋め込みやすいと考えて）

  ・配列にも更新の可/不可がある。

  ・ポインタは存在しない（ポインタはバグの温床という認識）

  ・classの継承は存在しない。代わりにprototype系の継承がある。（実装の継承は過度に隠ぺいされて可読性・メンテナンス性・保守性が悪いという認識）

  ・ガベージコレクタはない。ブロックスコープの単位でデストラクタが走りリソースが解放されます（GCは処理が重いときに走り始めるので嫌いです）

  ・タイプセーフ（静的型付け）な言語にしたい思いは強い（インターフェースが一致しない、型が一致しない場合はエラー。予定＆希望＆実装中）

  ・例外を多数実装。無限ループする前に例外が発生してループを抜けます。ゼロ除算、範囲外アクセス、未定義の例外は実装済。（未実装ですが、最大最小値超え、スタックメモリ枯渇、再帰上限超え、などを実装予定）

「大規模開発に耐えられる」
--------

  ・オブジェクトの概念がある。カプセル化の概念がある。

  ・STLのようなジェネリックな言語にしたい思いは強いです（関数の引数の型チェックはわざとしていない）。

  ・テストも重視。デバッグも重視。（未実装）

  ・可読性もメンテナンス性も重視。（希望）

「使って楽しい」
--------

  ・「list」と呼ぶ配列（コンテナ）がある。C++/STLでいうコンテナ。JavaやC#でいうコレクション。配列listと 連想配列map の両方の機能を持つ。番号のつく連想配列のこと。

  ・each がある。最近の言語では当たり前ですね。

  ・無名関数がある。

  ・クロージャーも・・・たぶんある。

  ・ジェネレータ yield もサポートしたい。（希望）

とにかく、プログラマが苦労しない言語を目指しています。


概要：
--------

コンパイラというか中間言語へのトランスレータ「Yamasemi」と、中間言語の実行部(いわゆるVM)「Kawasemi」の２段構成になっています。

現状、言語設計+試験期間な意味からコンパイラよりもインタープリタに近い状態です。現在は実装の確認という意味で JavaScript 書いています。
今後の予定としては、やはり C/C++ への移植です。JavaScriptで 1000行程度なので、C/C++ でも 4000行程度の軽量な実装になると予想しています。

型は現在、整数型(int)と文字列型(str)しかありません。早めに、bool, enum（シンボル？）はサポートしたいと思っています。
float やその他の型は外部のライブラリとして用意するつもり。（言語そのもののの実装を軽くしたいので。）

そしてテストとデバッグのしやすさを売りにしたいので test() や assert(), trace() とかを早めに実装したい。

■ 型付けモデルは？

-> 強い型付け(strong typing) Java
   弱い型付け(weak typing) C, PHP

-> 静的型付け(static typing) コンパイル時に型が決まる C++, Java
   動的型付け(dynamic typing) 実行時に型が決まる Ruby, PHP


■ オブジェクト指向は？
-> カプセル化 (いわゆる構造化と隠蔽 private)
   継承
        クラスベース C++, Java, C#, Ruby, PHP, Python, Scala
->      プロトタイプベース JavaScript, Io, Lua, Self
-> 多態性（ダックタイピング） Ruby, Python, Smalltalk, C++/template


■ プログラミングモデルは？

   関数型 Scala, Erlang, Clojure, Haskell, Scheme, Lisp
-> 手続き型 Basic, C, Fortran, Pascal
   論理ベース Plolog

   コンパイラ C, C++, Fortran, Pascal
-> インタプリタ(JIT) Java, Ruby, JavaScript, Perl, PHP, Basic


よろしくお願いします。

License
----------
The BSD 2-Clause License
BSDライセンス

Copyright (c) YAMAZAKI Satoshi. All rights reserved.

 -->
<head>
<title>BirdsScript</title>
<meta charset="UTF-8">
<style> body { background-color:#cccccc; } </style>
<script type="text/javascript" charset="utf-8" src="Yamasemi.mini.js"></script>
<script type="text/javascript" charset="utf-8" src="Kawasemi.js"></script>
<script>

var c_max = 0 ;
var c_NG = 0 ;
function birds_script( _in, _check1, _check2 )
{
    var interlanguage = yamasemi_compiler( _in, false ) ;
    var bgc1 = ( _check1 === interlanguage ) ? '#9D9' : '#D55' ;
    document.write( '<pre id="id'+c_max+'" style="background-color:'+bgc1+';padding:20px;">'+_in+'</pre>' ) ;

    if ( _check2 === 'NG' ) {
        document.write( '<pre style="background-color:#99D;padding:20px;">'+interlanguage+'<br></pre>' ) ;
    }
    else {
        var result = kawasemi_interpreter( interlanguage ) ;
        if ( _check2 === result )
            document.write( '<pre style="background-color:#99D;padding:20px;">'+result+'<br></pre>' ) ;
        else
        {
            document.write( '<pre style="background-color:#D55;padding:20px;">'+result+'<br>'+_check2+'<br></pre>' ) ;
            ++ c_NG ;
        }
    }
    document.write( '<div align="right" ><input type="button" value="test" onclick="document.getElementById(\'yamasemi\').value=document.getElementById(\'id'+c_max+'\').innerText;location.href=\'#\'" ></div>' ) ;
    ++ c_max ;
}
</script>
</head>
<body>
BirdsScript ver.0.01 (c) 2013/08 YAMAZAKI Satoshi.<br>
<!-- <a href="https://twitter.com/share" class="twitter-share-button" data-text="BirdsScript" data-lang="ja" data-size="large" data-count="none" data-hashtags="BirdsScript">ツイート</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script> <div class="g-plusone" data-annotation="none"></div><script type="text/javascript">window.___gcfg = {lang: 'ja'};(function() {var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;po.src = 'https://apis.google.com/js/plusone.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);})();</script> <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-noballoon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="http://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="http://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
<br> -->
試作ページとして公開を開始しました。(2013/12/23)<br>
現在も試作途中。public の表記を変更。.a -> #a。(2014/08/15)<br>
<textarea cols="60" rows="8" id="yamasemi">
--- sample code 階乗(fact) の関数宣言
fact : { _n <= 1 ?? 1 !! _n * fact( n:_n-1 ).0 } ;

--- 関数 fact を実行して結果を表示
@.co << fact( n:3 ).0 << "\n" ;
@.co << fact( n:5 ).0 << "\n" ;

</textarea>
<input type="button" id="BT1" value="コンパイル（中間コード生成）" onclick="
document.getElementById('kawasemi').value=yamasemi_compiler(document.getElementById('yamasemi').value, document.getElementById('debug_check').checked )" >
<input type="checkbox" id="debug_check" >デバッグ情報埋め込み<br>
<textarea cols="60" rows="5" id="kawasemi">
コードを書いて[コンパイル（中間コード生成）]ボタンを押すと、ここに中間コードが生成されます・・・直接入力してもいいけどね
</textarea>
<input type="button" id="BT1" value="中間コード実行" onclick="
document.getElementById('kawasemi_output').value=kawasemi_interpreter( document.getElementById('kawasemi').value, 'OK' )" ><br>
<textarea cols="60" rows="5" id="kawasemi_output" >
[中間コード実行]ボタンを押すと実行結果が表示されます
</textarea><br>
<pre>

以下、「BirdsScript」の文法です
-----------------------------------------------------------------
■ コメント

    '---' いわゆる C++ の // と同じ
    '...' 上と同じ

-----------------------------------------------------------------
■ Hello World.
</pre><script>

birds_script( "\
@.co << 'Hello' << 'World' ; ... @.co はコンソール出力の意味です。ちょっと C++/STL のような表記です。",
"(; (<< (<< (. @ .co ) 'Hello' ) 'World' ) )",
"HelloWorld"
) ;

birds_script( "\
@.co << 'Hello' ... 区切り文字 ';' は無くてもある程度は動きます。\n\
@.co << 'World' ... ただ、無いと優先順位がはっきりしない（可読性が悪い）ケースがあるので、なるべく書くことをおすすめします。",
"(<< (. @ .co ) 'Hello' ) (<< (. @ .co ) 'World' )",
"HelloWorld"
) ;

</script><pre>

-----------------------------------------------------------------
■ 定数/変数宣言

    予約語、というか演算子は次の２つ。 ':', '::'

    定数や変数の宣言には必ず初期値が必用です。
    空の変数や定数は存在させないことで、バグが入り込まないようにする設計方針です。

    古いC言語や Pascal のように、宣言文はスコープの先頭のみという制限はありません。好きなところで宣言できます。
    なるべくデータのスコープを小さくする（使用する直前で定義して、素早く片づける）ことが可読性のよいコードにつながると思っています。

    ':' は定数宣言です。 いわゆる C/C++の const、Javaの final、Scalaの val 。 一度設定した値を上書きすることはできません。

</pre><script>

birds_script( "\
i : 0 ;  ... 整数型 int の定数宣言\n\
i = 99 ; ... NG 代入（上書き）は失敗します",
"(; (: i 0 ) ) (; (= i 99 ) )",
"\nrun-time error: cannot be set to a read-only property.: i.int"
) ;
// birds_script( "\
//     str : "string\n" ; ... 文字列型定数 ... エスケープ有りの文字列',
//     "(: str 'string\n' )"
// ) ;
birds_script( "\
s : 'string' ; ... 文字列型 str の定数宣言 ... エスケープ無しの文字列\n\
s = 'STRING' ; ... NG 代入（上書き）は失敗します",
"(; (: s 'string' ) ) (; (= s 'STRING' ) )",
"\nrun-time error: cannot be set to a read-only property.: s.str"
) ;

</script><pre>

    変数の宣言には '::' を使います。
    変数の方が制約が緩い（危険）なので、ハイコスト（2文字）にしています。上手に使ってください。

</pre><script>

birds_script( "\
i :: 0 ;    ... 整数型 int の変数宣言.\n\
i = 99 ;    ... OK 代入は成功します\n\
\n\
@.co << i ; ... i を表示してみる",
"(; (:: i 0 ) ) (; (= i 99 ) ) (; (<< (. @ .co ) i ) )",
"99"
) ;

birds_script( "\
s :: 'string' ; ... 文字列型 str の変数宣言\n\
s = 'STRING' ;  ... OK 代入は成功します\n\
\n\
@.co << s ;     ... str を表示してみる",
"(; (:: s 'string' ) ) (; (= s 'STRING' ) ) (; (<< (. @ .co ) s ) )",
"STRING"
) ;

birds_script( "\
i :: 0 ;       ... 整数型 int の変数宣言.\n\
i = 'string' ; ... NG 型が違うので代入は失敗します",
"(; (:: i 0 ) ) (; (= i 'string' ) )",
"\nrun-time error: type mismatch.: i.int != literal.str"
) ;

birds_script( "\
s :: 'string' ; ... 文字列型 str の変数宣言\n\
s = 99 ;        ... NG 型が違うので代入は失敗します",
"(; (:: s 'string' ) ) (; (= s 99 ) )",
"\nrun-time error: type mismatch.: s.str != literal.int"
) ;

</script><pre>
-----------------------------------------------------------------
■ if文 条件分岐

    'if', 'else' という予約語はありません。
    C言語の三項演算子のような演算子 '??', '!!' を使います。

    最初は '?', '!' の1文字だったのですが、文中に埋もれてしまって目立たないので2文字になりました。

</pre><script>

birds_script( "\
foo :: 1 ;\n\
foo > 0 ?? foo = 0 ; ... if 文 ... = は代入文\n\
\n\
@.co << foo ;        ... foo を表示してみる",
"(; (:: foo 1 ) ) (; (?? (> foo 0 ) { (= foo 0 ) } ) ) (; (<< (. @ .co ) foo ) )",
"0"
) ;

birds_script( "\
foo :: 1 ;\n\
foo > 0 ?? foo = 0 !! foo = 1 ; ... if then else 文\n\
\n\
@.co << foo ; ... foo を表示してみる",
"(; (:: foo 1 ) ) (; (?? (> foo 0 ) { (= foo 0 ) } { (= foo 1 ) } ) ) (; (<< (. @ .co ) foo ) )",
"0"
) ;

birds_script( "\
foo :: 1 ;\n\
boo : foo > 0 ?? 0 !! 1 ;\n\
\n\
@.co << foo << ', ' ; ... foo を表示してみる\n\
@.co << boo ;         ... boo を表示してみる",
"(; (:: foo 1 ) ) (; (: boo (?? (> foo 0 ) { 0 } { 1 } ) ) ) (; (<< (<< (. @ .co ) foo ) ', ' ) ) (; (<< (. @ .co ) boo ) )",
"1, 0"
) ;

</script><pre>

    '??' の前は必ず比較文である必要があります。比較文以外はsyntax-errorになります。
    flag = true ?? ... のようなタイポを防ぐ理由があります。

    true, false は予約語です。true, false の型は enum になる予定。

</pre><script>

birds_script( "\
is_ok : true ; a :: 0 ;\n\
is_ok ?? a=1 !! a=2 ; ... NG",
"syntax-error: '??'",
"NG"
) ;

birds_script( "\
is_ok : true ; a :: 0 ;\n\
is_ok == true ?? a=1 !! a=2 ; ... OK\n\
\n\
@.co << a ;                   ... a を表示してみる",
"(; (: is_ok true ) ) (; (:: a 0 ) ) (; (?? (== is_ok true ) { (= a 1 ) } { (= a 2 ) } ) ) (; (<< (. @ .co ) a ) )",
"1"
) ;

</script><pre>

    現在のところ else文のみの書き方はNGになっています。
    メリットが感じられるようなら実装を検討します。そんなに難しい事ではないはず。

</pre><script>

birds_script( "\
foo >= 0 !! foo = 0 ; ... NG",
"syntax-error: '!!'",
"NG"
) ;

</script><pre>


-----------------------------------------------------------------
■ スコープ（ブロックスコープ） '(', ')'

    いわゆるC言語やJavaの表記は '{','}' ですがBirdsScriptでは '(', ')' になります。注意してください。

    変数/定数の参照範囲が制限できるのと、リソースの開放ができるので上手に使ってください。

    BirdsScript にはスコープのようにカッコで囲む構文が５種類あります。
    のちほど順番に解説しますが、まずは一覧と簡単な概要を紹介します。

    1, scope    (   )   実行の優先順位を示します。その場で実行され値を１つ返します。
    2, list     [   ]   いわゆる便利な配列です。その場で実行され listを返します。
    3, function {   }   関数を返します。呼ばれるまで実行はされません。実行後に listを返します。
    4, loop     {{  }}  範囲内を繰り返し実行します。その場で実行され listを返します。
    5, each     .{{ }}  引数のある繰り返し文です。その場で実行され listを返します。

</pre><script>

birds_script( "\
boo :: foo :: woo :: 5 ;\n\
foo < 0\n\
?? ( boo = 0 ; foo = 0 ; woo = 0 ; )\n\
!! ( boo = 1 ; foo = 1 ; woo = 1 ; )\n\
\n\
@.co << boo << ', ' << foo << ', ' << woo ; ... foo, boo, woo を表示してみる",
"(; (:: boo (:: foo (:: woo 5 ) ) ) ) (; (?? (< foo 0 ) { (scope { (; (= boo 0 ) ) (; (= foo 0 ) ) (; (= woo 0 ) ) } ) } { (scope { (; (= boo 1 ) ) (; (= foo 1 ) ) (; (= woo 1 ) ) } ) } ) (<< (<< (<< (<< (<< (. @ .co ) boo ) ', ' ) foo ) ', ' ) woo ) )",
"1, 1, 1"
) ;

birds_script( "\
boo :: foo :: woo :: 5 ;\n\
foo < 0\n\
?? (\n\
    boo = 0 ;\n\
    foo = 0 ;\n\
    woo = 0 ;\n\
)\n\
!! (\n\
    boo = 1 ;\n\
    foo = 2 ;\n\
    woo = 3 ;\n\
)\n\
\n\
@.co << boo << ', ' << foo << ', ' << woo ; ... foo, boo, woo を表示してみる",
"(; (:: boo (:: foo (:: woo 5 ) ) ) ) (; (?? (< foo 0 ) { (scope { (; (= boo 0 ) ) (; (= foo 0 ) ) (; (= woo 0 ) ) } ) } { (scope { (; (= boo 1 ) ) (; (= foo 2 ) ) (; (= woo 3 ) ) } ) } ) (<< (<< (<< (<< (<< (. @ .co ) boo ) ', ' ) foo ) ', ' ) woo ) )",
"1, 2, 3"
) ;

</script><pre>

    スコープ '(', ')' に値を持たせることができます。
    最後の値がひとつだけ返ります。

</pre><script>

birds_script( "\
boo :: foo :: woo :: 5 ;\n\
b : (\n\
    boo = 1 ;\n\
    foo = 2 ;\n\
    woo = 3 ;\n\
    boo         ... 最後の';'を書かなければこの値が返ります\n\
) ;\n\
\n\
@.co << b ;     ... b : 1",
"(; (:: boo (:: foo (:: woo 5 ) ) ) ) (; (: b (scope { (; (= boo 1 ) ) (; (= foo 2 ) ) (; (= woo 3 ) ) boo } ) ) ) (; (<< (. @ .co ) b ) )",
"1"
) ;


birds_script( "\
boo :: foo :: woo :: 5 ;\n\
b : (\n\
    boo = 1 ;\n\
    foo = 2 ;\n\
    woo = 3 ;\n\
    boo ;       ... ちなみに最後に';'を書くと直前に評価した値がクリアされるので...\n\
) ;\n\
\n\
@.co << b ;     ... b : [] 空の配列 list が返されます",
"(; (:: boo (:: foo (:: woo 5 ) ) ) ) (; (: b (scope { (; (= boo 1 ) ) (; (= foo 2 ) ) (; (= woo 3 ) ) (; boo ) } ) ) ) (; (<< (. @ .co ) b ) )",
"[ ]"
) ;

</script><pre>

    複数の値を返したい場合は listを使ってください。
    listの詳細については次項で説明します。

</pre><script>

birds_script( "\
boo :: foo :: woo :: 5 ;\n\
b : (\n\
    boo = 1 ;\n\
    foo = 2 ;\n\
    woo = 3 ;\n\
    [ boo, foo, woo, ]  ... listの宣言。最後の';'を書かなければこの値が返ります\n\
) ;\n\
\n\
@.co << b ;     ... b : [ 1, 2, 3, ]",
"(; (:: boo (:: foo (:: woo 5 ) ) ) ) (; (: b (scope { (; (= boo 1 ) ) (; (= foo 2 ) ) (; (= woo 3 ) ) [ (, boo ) (, foo ) (, woo ) ] } ) ) ) (; (<< (. @ .co ) b ) )",
"[ 1, 2, 3, ]"
) ;

</script><pre>

    計算途中の値も返すことができますが、混乱の無いようにあとで説明します。

-----------------------------------------------------------------------
■ リスト '[', ']'。 いわゆる便利な配列です。

    BirdsScript でサポートしている便利な配列は「リストオブジェクト(list)」と呼ぶことにしました。
    '[', ']' で表記します。
    配列であり、連想配列でもあり、オブジェクトでもある汎用的な入れ物です。

    C++/STLの std::vector, std::map の両方の機能が混在しているコンテナになります。

</pre><script>

birds_script( "\
int_list : [ 1, 2, 3, 4, 5, ] ;\n\
str_list : [ '1', '2', '3', ] ;\n\
\n\
@.co << int_list[0] << \"\\n\" ; ... 1\n\
@.co << str_list[2] << \"\\n\" ; ... 3\n\
\n\
@.co << int_list << \"\\n\" ;    ... listそのものを表示してみる\n\
@.co << str_list ;",
"(; (: int_list [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) ] ) ) (; (: str_list [ (, '1' ) (, '2' ) (, '3' ) ] ) ) (; (<< (<< (. @ .co ) (at int_list 0 ) ) '\n' ) ) (; (<< (<< (. @ .co ) (at str_list 2 ) ) '\n' ) ) (; (<< (<< (. @ .co ) int_list ) '\n' ) ) (; (<< (. @ .co ) str_list ) )",
"1\n3\n[ 1, 2, 3, 4, 5, ]\n[ 1, 2, 3, ]"
) ;

birds_script( "\
str_map1 : [ 1:'one', 2:'two', ] ;\n\
str_map2 : [ a:'one', b:'two', ] ;\n\
\n\
@.co << str_map1[2] << \"\\n\" ; ... two\n\
@.co << str_map2.b  << \"\\n\" ; ... two\n\
\n\
@.co << str_map1 << \"\\n\" ;    ... listそのものを表示してみる\n\
@.co << str_map2 ;",
"(; (: str_map1 [ (, (: 1 'one' ) ) (, (: 2 'two' ) ) ] ) ) (; (: str_map2 [ (, (: a 'one' ) ) (, (: b 'two' ) ) ] ) ) (; (<< (<< (. @ .co ) (at str_map1 2 ) ) '\n' ) ) (; (<< (<< (. @ .co ) (. str_map2 .b ) ) '\n' ) ) (; (<< (<< (. @ .co ) str_map1 ) '\n' ) ) (; (<< (. @ .co ) str_map2 ) )",
"two\ntwo\n[ one, two, ]\n[ one, two, ]"
) ;

</script><pre>

    リストも、宣言の違いで、追加可能/不可能が変わります。

</pre><script>

birds_script( "\
list_a : [] ; ... 追加不可な配列\n\
\n\
list_a << 1 ;  ...  NG",
"(; (: list_a [  ] ) ) (; (<< list_a 1 ) )",
"\nrun-time error: cannot be set to a read-only property.: list_a.list"
) ;

birds_script( "\
list_b :: [] ; ... 追加可能な配列\n\
\n\
list_b << 1 ;  ...  OK\n\
\n\
@.co << list_b ; ... [ 1, ]",
"(; (:: list_b [  ] ) ) (; (<< list_b 1 ) ) (; (<< (. @ .co ) list_b ) )",
"[ 1, ]"
) ;

</script><pre>

    ２次元配列も木構造も作れます。

</pre><script>

birds_script( "\
list_a : [ [ 1, 2, ], [ 10, 20, ], [ 100, 200, ], ] ; ... ２次元配列\n\
\n\
list_a.{{ it.{{ @.co << it << ', ' ; }} ; }} ; ... it は予約語です。詳細は後ほど。\n\
@.co << list_a ;",
"(; (: list_a [ (, [ (, 1 ) (, 2 ) ] ) (, [ (, 10 ) (, 20 ) ] ) (, [ (, 100 ) (, 200 ) ] ) ] ) ) (; (each list_a { (; (each it { (; (<< (<< (. @ .co ) it ) ', ' ) ) } ) ) } ) ) (; (<< (. @ .co ) list_a ) )",
"1, 2, 10, 20, 100, 200, [ [ 1, 2, ], [ 10, 20, ], [ 100, 200, ], ]"
) ;

birds_script( "\
list_a : [ [ 1, 2 ], [ 10, [ 20, 21 ], 30 ], [ 100 ] ] ; ... 最後の要素の区切り ',' は無くても動きますがバグを呼ぶのでなるべく書きましょう。\n\
\n\
put_tree : {                    ... 型がリストオブジェクト'list' の場合に再帰する木構造表示用関数を作成\n\
    _v.type == 'list'           ... .type は予約語です。詳細は後ほど。\n\
    ?? _v.{{ put_tree( v:it ) ; }}\n\
    !! @.co << _v << ', '\n\
}\n\
\n\
put_tree( v:list_a ) ;\n\
@.co << list_a ;",
"(; (: list_a [ (, [ (, 1 ) 2 ] ) (, [ (, 10 ) (, [ (, 20 ) 21 ] ) 30 ] ) [ 100 ] ] ) ) (; (: put_tree { (?? (== (. _v .type ) 'list' ) { (each _v { (; (call put_tree [ (: v it ) ] ) ) } ) } { (<< (<< (. @ .co ) _v ) ', ' ) } ) } ) (call put_tree [ (: v list_a ) ] ) ) (; (<< (. @ .co ) list_a ) )",
"1, 2, 10, 20, 21, 30, 100, [ [ 1, 2, ], [ 10, [ 20, 21, ], 30, ], [ 100, ], ]"
) ;

</script><pre>

    実は区切り記号 ',' を書かなくても通ります。が、何度も書きますが可読性（メンテナンス性）を優先してください。

</pre><script>

birds_script( "\
list_a : [1 2 3 4 5] ; ... list内の区切り記号 ',' を省略してみる\n\
\n\
@.co << list_a ;",
"(; (: list_a [ 1 2 3 4 5 ] ) ) (; (<< (. @ .co ) list_a ) )",
"[ 1, 2, 3, 4, 5, ]"
) ;

</script><pre>

-----------------------------------------------------------------------
■ switch文  条件分岐（その２）

    ちょっと脱線
    switch文は無いので関数の listと関数宣言で実装します。
    関数に関しては後で詳しく説明しますので、雰囲気だけつかんでください。

</pre><script>

birds_script( "\
sw : [                            ... 固定テーブル（マップ）\n\
    1 : { @.co << 'one, ' ; },    ... 関数{} を指定します。 ブロック() で書くと先に実行しちゃいます。\n\
    2 : { @.co << 'two, ' ; },\n\
] ;\n\
\n\
@.co << sw << ', ' ;  ... [ {}, {}, {}, ]\n\
sw[1]()  ;            ... one, \n\
sw[2]()  ;            ... two, \n\
sw[99]() ;            ... unmatch",
"(; (: sw [ (, (: 1 { (; (<< (. @ .co ) 'one, ' ) ) } ) ) (, (: 2 { (; (<< (. @ .co ) 'two, ' ) ) } ) ) ] ) ) (; (<< (<< (. @ .co ) sw ) ', ' ) ) (; (call (at sw 1 ) [  ] ) ) (; (call (at sw 2 ) [  ] ) ) (; (call (at sw 99 ) [  ] ) )",
"[ { }, { }, ], one, two, \nexception: on_unmatch unmatch member-name.: .99"
) ;

birds_script( "\
sw : [                                  ... 固定テーブル（マップ）\n\
    unmatch : { @.co << 'unmatch' ; },  ... 一致しなかった時に呼ばれる関数 ... unmatch は予約語です。\n\
    1 : { @.co << 'one, ' ; },          ... 関数{} を指定します。 ブロック() で書くと先に実行しちゃいます。\n\
    2 : { @.co << 'two, ' ; },\n\
] ;\n\
\n\
@.co << sw << ', ' ;  ... [ {}, {}, ]\n\
sw[2]()  ;            ... two,\n\
sw[99]() ;            ... unmatch",
"(; (: sw [ (, (: unmatch { (; (<< (. @ .co ) 'unmatch' ) ) } ) ) (, (: 1 { (; (<< (. @ .co ) 'one, ' ) ) } ) ) (, (: 2 { (; (<< (. @ .co ) 'two, ' ) ) } ) ) ] ) ) (; (<< (<< (. @ .co ) sw ) ', ' ) ) (; (call (at sw 2 ) [  ] ) ) (; (call (at sw 99 ) [  ] ) )",
"[ { }, { }, { }, ], two, unmatch"
) ;
// ↓これは存在しない sw[1] に代入ってのはちょっと無謀だよね。エラーでいいと思う。
// birds_script( "\
//     sw :: [] ; ... 可変テーブル（マップ）、後から追加・変更可能。\n\
//     sw[1] = { @.co << 'one' } ;\n\
//     sw[2] = { @.co << 'two' } ;\n\
//     sw[unmatch] = { @.co << it } ;  ... 一致しなかった時に呼ばれる関数\n\
//     @.co << sw[2]() ; ... 'two' ",
//     "(:: sw [  ] ) (= (at sw 1 ) { (<< (. @ .co ) 'one' ) } ) (= (at sw 2 ) { (<< (. @ .co ) 'two' ) } ) (= (at sw unmatch ) { (<< (. @ .co ) it ) } ) (<< (. @ .co ) (call (at sw 2 ) [  ] ) )",
//      ''
// ) ;
birds_script( "\
sw :: [      ... 可変テーブル（マップ）、後から追加・変更可能。\n\
    unmatch : { @.co << 'unmatch' ; },  ... 一致しなかった時に呼ばれる関数\n\
] ;\n\
sw << ( 1 : { @.co << 'one, ' ; } ) ;\n\
sw << ( 2 : { @.co << 'two, ' ; } ) ;\n\
\n\
@.co << sw << ', ' ;  ... [ {}, {}, ]\n\
sw[2]()  ;            ... two,\n\
sw[99]() ;            ... unmatch",
"(; (:: sw [ (, (: unmatch { (; (<< (. @ .co ) 'unmatch' ) ) } ) ) ] ) ) (; (<< sw (scope { (: 1 { (; (<< (. @ .co ) 'one, ' ) ) } ) } ) ) ) (; (<< sw (scope { (: 2 { (; (<< (. @ .co ) 'two, ' ) ) } ) } ) ) ) (; (<< (<< (. @ .co ) sw ) ', ' ) ) (; (call (at sw 2 ) [  ] ) ) (; (call (at sw 99 ) [  ] ) )",
"[ { }, { }, { }, ], two, unmatch"
) ;

</script><pre>

    個人的には switch文の代わりに if文の羅列でもいいんじゃないかと思う。

</pre><script>

birds_script( "\
sw : {\n\
    _in == 1 ?? @.co << 'one, ' !!\n\
    _in == 2 ?? @.co << 'two, ' !!\n\
    @.co << 'unmatch' ;\n\
} ;\n\
\n\
sw( in:2 )  ;   ... two,\n\
sw( in:99 ) ;   ... unmatch",
"(; (: sw { (; (?? (== _in 1 ) { (<< (. @ .co ) 'one, ' ) } { (?? (== _in 2 ) { (<< (. @ .co ) 'two, ' ) } { (<< (. @ .co ) 'unmatch' ) } ) } ) ) } ) ) (; (call sw [ (: in 2 ) ] ) ) (; (call sw [ (: in 99 ) ] ) )",
"two, unmatch"
) ;

</script><pre>

-----------------------------------------------------------------
■ ループ '{{', '}}'    繰り返し（その１） loop文

    予約語 break[], continue[]

    ループは '{{', '}}' で表記します。意味としては無限ループ for(;;){ ... } です。

    ちなみに無限ループと完全に等価ではなくて、リミット上限に到達すると例外が発生して勝手にループを抜けます。
    また break[] 文が無いとワーニングの予定（未実装）。できる限り安全側に倒したい（希望）。

</pre><script>

birds_script( "\
--- たとえば C言語風の for ( int i=0 ; i < 10 ; i++ ) ... をあえて書くなら\n\
i :: 0 ;\n\
{{\n\
    i >= 10 ?? break[] ;\n\
    \n\
    @.co << i << ', ' ;  ... i を表示してみる\n\
    \n\
    ++i ; ... C言語などの後方 i++ と異なり「先に実行される」のであえて前方のみにしました。\n\
}}",
"(; (:: i 0 ) ) (loop { (; (?? (>= i 10 ) { (break [  ] ) } ) ) (; (<< (<< (. @ .co ) i ) ', ' ) ) (; (++ i ) ) } )",
"0, 1, 2, 3, 4, 5, 6, 7, 8, 9, "
) ;

</script><pre>

    break[] は値を複数返すことができます。

</pre><script>

birds_script( "\
@.co << {{\n\
    @.co << 'A, ' ;    ... この行を何回通るか表示してみる\n\
    break [ 10, 20 ] ; ... 複数の値を指定してループを抜ける\n\
    @.co << 'B, ' ;\n\
    continue [] ;      ... ここは実行されないけどね\n\
    @.co << 'C, ' ;\n\
}} ;                   ... [ 10, 20, ] list が返る\n\
",
"(; (<< (. @ .co ) (loop { (; (<< (. @ .co ) 'A, ' ) ) (; (break [ (, 10 ) 20 ] ) ) (; (<< (. @ .co ) 'B, ' ) ) (; (continue [  ] ) ) (; (<< (. @ .co ) 'C, ' ) ) } ) ) )",
"A, [ 10, 20, ]"
) ;

birds_script( "\
@.co << {{\n\
    @.co << 'A, ' ;\n\
    break 10 ;      ... ループを抜ける。戻り値が list ではないので実行時 run-time errorになります。できればコンパイルエラーにしたい。\n\
    @.co << 'B, ' ;\n\
    continue 20 ;\n\
    @.co << 'C, ' ;\n\
}}     ... 10 を表示したいけど・・・\n\
",
"(<< (. @ .co ) (loop { (; (<< (. @ .co ) 'A, ' ) ) (; (break 10 ) ) (; (<< (. @ .co ) 'B, ' ) ) (; (continue 20 ) ) (; (<< (. @ .co ) 'C, ' ) ) } ) )",
"A, \nrun-time error: argument type is not list.: (break"
) ;

birds_script( "\
@.co << {{\n\
    @.co << 'A, ' ;\n\
    break [] ;       ... 戻り値無しでループを抜ける\n\
    @.co << 'B, ' ;\n\
    continue [] ;\n\
    @.co << 'C, ' ;\n\
}} ;\n\
",
"(; (<< (. @ .co ) (loop { (; (<< (. @ .co ) 'A, ' ) ) (; (break [  ] ) ) (; (<< (. @ .co ) 'B, ' ) ) (; (continue [  ] ) ) (; (<< (. @ .co ) 'C, ' ) ) } ) ) )",
"A, [ ]"
) ;

birds_script( "\
i :: 0 ;\n\
@.co << {{\n\
    ++ i ;\n\
    i > 7 ?? break [ 555 ] ;\n\
    i % 2 == 0 ?? continue [ 111 ] ;\n\
    i\n\
}} ;\n\
",
"(; (:: i 0 ) ) (; (<< (. @ .co ) (loop { (; (++ i ) ) (; (?? (> i 7 ) { (break [ 555 ] ) } ) ) (; (?? (== (% i 2 ) 0 ) { (continue [ 111 ] ) } ) ) i } ) ) )",
"[ 1, 111, 3, 111, 5, 111, 7, 555, ]"
) ;

</script><pre>

    continue[] 文のサンプルコードは FizzBuzz 問題です。

</pre><script>

birds_script( "\
--- FizzBuzz 問題\n\
i :: 0 ;\n\
{{\n\
    ++i > 20 ?? break[] ;\n\
    i % 15 == 0 ?? ( @.co << 'FizzBuzz, ' ; continue [] ; )\n\
    i % 3  == 0 ?? ( @.co << 'Fizz, ' ; continue [] ; )\n\
    i % 5  == 0 ?? ( @.co << 'Buzz, ' ; continue [] ; )\n\
    \n\
    @.co << i << ', ' ;  ... i を表示\n\
}}",
"(; (:: i 0 ) ) (loop { (; (?? (> (++ i ) 20 ) { (break [  ] ) } ) ) (; (?? (== (% i 15 ) 0 ) { (scope { (; (<< (. @ .co ) 'FizzBuzz, ' ) ) (; (continue [  ] ) ) } ) } ) (?? (== (% i 3 ) 0 ) { (scope { (; (<< (. @ .co ) 'Fizz, ' ) ) (; (continue [  ] ) ) } ) } ) (?? (== (% i 5 ) 0 ) { (scope { (; (<< (. @ .co ) 'Buzz, ' ) ) (; (continue [  ] ) ) } ) } ) (<< (<< (. @ .co ) i ) ', ' ) ) } )",
"1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, 17, Fizz, 19, Buzz, "
) ;

birds_script( "\
--- FizzBuzz 問題。その２。\n\
--- もう少し BirdsScript の特長を生かした書き方版です。\n\
--- continue [] ではなく each文を使っています。each文の詳細については次の項目を参考にしてください。\n\
@.co << 20.{{\n\
    i : it + 1 ;\n\
       i % 15 == 0 ?? 'FizzBuzz'\n\
    !! i %  3 == 0 ?? 'Fizz'\n\
    !! i %  5 == 0 ?? 'Buzz'\n\
    !! i\n\
}}",
"(<< (. @ .co ) (each 20 { (; (: i (+ it 1 ) ) ) (?? (== (% i 15 ) 0 ) { 'FizzBuzz' } { (?? (== (% i 3 ) 0 ) { 'Fizz' } { (?? (== (% i 5 ) 0 ) { 'Buzz' } { i } ) } ) } ) } ) )",
"[ 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, 17, Fizz, 19, Buzz, ]"
) ;

birds_script( "\
--- FizzBuzz 問題。その３。\n\
--- continue [] の list に載せる機能を積極的に使う。\n\
@.co << 20.{{\n\
    i : it + 1 ;\n\
    i % 15 == 0 ?? continue [ 'FizzBuzz' ] ;\n\
    i %  3 == 0 ?? continue [ 'Fizz' ] ;\n\
    i %  5 == 0 ?? continue [ 'Buzz' ] ;\n\
    i\n\
}} ;\n\
",
"(; (<< (. @ .co ) (each 20 { (; (: i (+ it 1 ) ) ) (; (?? (== (% i 15 ) 0 ) { (continue [ 'FizzBuzz' ] ) } ) ) (; (?? (== (% i 3 ) 0 ) { (continue [ 'Fizz' ] ) } ) ) (; (?? (== (% i 5 ) 0 ) { (continue [ 'Buzz' ] ) } ) ) i } ) ) )",
"[ 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, 17, Fizz, 19, Buzz, ]"
) ;

</script><pre>

    ループを抜けると list を返します。実行した結果が配列の中に格納されまとめて返されます。

</pre><script>

birds_script( "\
--- C言語風の for ( int i=0 ; i < 4 ; i++ ) で\n\
i :: 0 ;\n\
a : {{                   ... ループの戻り値 list を a に\n\
    i >= 4 ?? break [] ; ... 戻り値無しでループを抜ける\n\
    i,                   ... i を戻り値 list に積む\n\
    ++i ;\n\
}} ;\n\
@.co << a ;             ... a を表示してみる [ 0, 1, 2, 3, ]",
"(; (:: i 0 ) ) (; (: a (loop { (; (?? (>= i 4 ) { (break [  ] ) } ) ) (, i ) (; (++ i ) ) } ) ) ) (; (<< (. @ .co ) a ) )",
"[ 0, 1, 2, 3, ]"
) ;

birds_script( "\
--- C言語風の for ( int i=0 ; i < 4 ; i++ ) で\n\
i :: 0 ;\n\
a : {{                              ... ループの戻り値 list を a に\n\
    i >= 4 ?? break[ 44, 55, ] ;    ... さらに終了時にも値を追加する\n\
    i,                              ... i を戻り値 list に積む\n\
    ++i ;\n\
}} ;\n\
@.co << a ;                         ... a を表示してみる [ 0, 1, 2, 3, 44, 55, ]",
"(; (:: i 0 ) ) (; (: a (loop { (; (?? (>= i 4 ) { (break [ (, 44 ) (, 55 ) ] ) } ) ) (, i ) (; (++ i ) ) } ) ) ) (; (<< (. @ .co ) a ) )",
"[ 0, 1, 2, 3, 44, 55, ]"
) ;

birds_script( "\
--- C言語風の for ( int i=0 ; i < 4 ; i++ ) で\n\
i :: 0 ;\n\
a : {{          ... 戻り値 list を a に\n\
    i >= 4 ?? break[] ;\n\
    i,\n\
    ++i,        ... 異なる値を複数回積むこともできます\n\
}} ;\n\
@.co << a ;     ... a を表示してみる [ 0, 1, 1, 2, 2, 3, 3, 4, ]",
"(; (:: i 0 ) ) (; (: a (loop { (; (?? (>= i 4 ) { (break [  ] ) } ) ) (, i ) (, (++ i ) ) } ) ) ) (; (<< (. @ .co ) a ) )",
"[ 0, 1, 1, 2, 2, 3, 3, 4, ]"
) ;

</script><pre>


-----------------------------------------------------------------
■ each文 '.{{', '}}'  繰り返しその２、each 文

    繰り返し構文といえば each でしょ。 loop文は break[] する必要があるのでできることなら使いたくない。

    each文は '.{{', '}}' で表します。

    'it', 'idx' は繰り返し時に暗黙的に定義され、値が渡される変数です。予約語になります。

    it : イテレータの意味。list の場合は各要素の値が入ります。
    idx : インデックスの意味。list の場合は各要素の名前が入ります。

    memo: enum, funcはNGです。

</pre><script>

birds_script( "\
5.{{ @.co << it << ', ' ; }}  ... 0, 1, 2, 3, 4, ",
"(each 5 { (; (<< (<< (. @ .co ) it ) ', ' ) ) } )",
"0, 1, 2, 3, 4, "
) ;

birds_script( "\
5.{{ @.co << idx << ', ' ; }}  ... 0, 1, 2, 3, 4, ",
"(each 5 { (; (<< (<< (. @ .co ) idx ) ', ' ) ) } )",
"0, 1, 2, 3, 4, "
) ;

birds_script( "\
'string'.{{ @.co << it << ', ' ; }}  ... s, t, r, i, n, g, ",
"(each 'string' { (; (<< (<< (. @ .co ) it ) ', ' ) ) } )",
"s, t, r, i, n, g, "
) ;

birds_script( "\
'string'.{{ @.co << idx << ', ' ; }}  ... 0, 1, 2, 3, 4, 5, ",
"(each 'string' { (; (<< (<< (. @ .co ) idx ) ', ' ) ) } )",
"0, 1, 2, 3, 4, 5, "
) ;

</script><pre>

    it も idx も定数扱いなので更新することはできません。

</pre><script>

birds_script( "\
5.{{ it = 999 ; }}  ... NG ",
"(each 5 { (; (= it 999 ) ) } )",
"\nrun-time error: cannot be set to a read-only property.: it.int"
) ;

birds_script( "\
5.{{ idx = 999 ; }}  ... NG ",
"(each 5 { (; (= idx 999 ) ) } )",
"\nrun-time error: cannot be set to a read-only property.: idx.int"
) ;

</script><pre>

    実は、ループ文にも idx があります。it は無いです。

</pre><script>

birds_script( "\
a : {{          ... 戻り値 list を a に\n\
    idx >= 4 ?? break[ 555 ] ;\n\
    idx * 10,\n\
}} ;\n\
@.co << a ;     ... a を表示してみる [ 0, 10, 20, 30, 555, ]",
"(; (: a (loop { (; (?? (>= idx 4 ) { (break [ 555 ] ) } ) ) (, (* idx 10 ) ) } ) ) ) (; (<< (. @ .co ) a ) )",
"[ 0, 10, 20, 30, 555, ]"
) ;

</script><pre>

    listと each の組み合わせ

</pre><script>

birds_script( "\
pi : [ 3, 1, 4, 1, 5, 9, 2, ] ;\n\
pi.{{\n\
    @.co << it << ', ' ;   ... 3, 1, 4, 1, 5, 9, 2, \n\
}} ;",
"(; (: pi [ (, 3 ) (, 1 ) (, 4 ) (, 1 ) (, 5 ) (, 9 ) (, 2 ) ] ) ) (; (each pi { (; (<< (<< (. @ .co ) it ) ', ' ) ) } ) )",
"3, 1, 4, 1, 5, 9, 2, "
) ;

birds_script( "\
[ 3, 1, 4, 1, 5, 9, 2, ].{{\n\
    @.co << idx << ':' << it << ', ' ;   ... 0:3, 1:1, 2:4, 3:1, 4:5, 5:9, 6:2, \n\
}} ;",
"(; (each [ (, 3 ) (, 1 ) (, 4 ) (, 1 ) (, 5 ) (, 9 ) (, 2 ) ] { (; (<< (<< (<< (<< (. @ .co ) idx ) ':' ) it ) ', ' ) ) } ) )",
"0:3, 1:1, 2:4, 3:1, 4:5, 5:9, 6:2, "
) ;

birds_script( "\
hw : [ h:'Hello', w:'World', ] ;  ... もちろん連想配列も each できます\n\
hw.{{\n\
    @.co << idx << ':' << it << ', ' ;   ... h:Hello, w:World, \n\
}} ;",
"(; (: hw [ (, (: h 'Hello' ) ) (, (: w 'World' ) ) ] ) ) (; (each hw { (; (<< (<< (<< (<< (. @ .co ) idx ) ':' ) it ) ', ' ) ) } ) )",
"h:Hello, w:World, "
) ;

</script><pre>

    loop文と同じく、each文でも break[]は値を返すことができます。戻り値も同じく list。

</pre><script>

birds_script( "\
b : 10.{{\n\
    @.co << it << ', ' ;   ... 0, 1, 2, 3, 4, 5,\n\
    \n\
    it == 5 ?? break[ 555 ] ;\n\
}} ;\n\
@.co << b ; ... [ 555 ]",
"(; (: b (each 10 { (; (<< (<< (. @ .co ) it ) ', ' ) ) (; (?? (== it 5 ) { (break [ 555 ] ) } ) ) } ) ) ) (; (<< (. @ .co ) b ) )",
"0, 1, 2, 3, 4, 5, [ 555, ]"
) ;

birds_script( "\
b : 10.{{\n\
    @.co << it << ', ' ;   ... 0, 1, 2, 3, 4, 5,\n\
    \n\
    it == 5 ?? break ; ... 引数（戻り値？）を忘れると NG\n\
}} ;\n\
@.co << b ; ... [ ]",
"syntax-error: '??'",
"NG"
) ;

</script><pre>

    each文も繰り返し実行した結果を listに格納して返します。

</pre><script>

birds_script( "\
@.co << 5.{{ it }} ; ... [ 0, 1, 2, 3, 4, ]",
"(; (<< (. @ .co ) (each 5 { it } ) ) )",
"[ 0, 1, 2, 3, 4, ]"
) ;

birds_script( "\
@.co << 5.{{ it*2+1 }} ; ... [ 1, 3, 5, 7, 9, ]",
"(; (<< (. @ .co ) (each 5 { (+ (* it 2 ) 1 ) } ) ) )",
"[ 1, 3, 5, 7, 9, ]"
) ;

birds_script( "\
@.co << 5.{{ it % 2 == 0 }} ; ... [ true, false, true, false, true, ]",
"(; (<< (. @ .co ) (each 5 { (== (% it 2 ) 0 ) } ) ) )",
"[ true, false, true, false, true, ]"
) ;

</script><pre>

    listに値を返す時に次のような注意が必要です。

    １回のループ処理で、複数の値を listに積むことができる。
    もしくは、積まないこともできる。その「積む」「積まない」を決める構文が、 ',' と ';' です。

    ',' ：直前に評価した値を戻り値の list に積む。
    ';' ：直前に評価した値を戻り値の list に積まずに捨てる。

    ここは BirdsScriptの特徴的な動作になるので、ゆっくり理解してください。

</pre><script>

birds_script( "\
@.co << 3.{{ it, it, }} ; ... [ 0, 0, 1, 1, 2, 2, ]",
"(; (<< (. @ .co ) (each 3 { (, it ) (, it ) } ) ) )",
"[ 0, 0, 1, 1, 2, 2, ]"
) ;

birds_script( "\
@.co << 3.{{ it*2, it*3, }} ; ... [ 0, 0, 2, 3, 4, 6, ]",
"(; (<< (. @ .co ) (each 3 { (, (* it 2 ) ) (, (* it 3 ) ) } ) ) )",
"[ 0, 0, 2, 3, 4, 6, ]"
) ;

birds_script( "\
@.co << 3.{{ it*2, it*3; }} ; ... [ 0, 2, 4, ] ... it*3 は実行され計算され（処理され）ますが結果はlistに積まれません",
"(; (<< (. @ .co ) (each 3 { (, (* it 2 ) ) (; (* it 3 ) ) } ) ) )",
"[ 0, 2, 4, ]"
) ;

birds_script( "\
@.co << 5.{{ it; }}  ... [  ] ... ';' でスタックがクリアされます。",
"(<< (. @ .co ) (each 5 { (; it ) } ) )",
"[ ]"
) ;

</script><pre>

    また、 break[], continue[] の動作も list に積む/積まないが関係します。

</pre><script>

birds_script( "\
@.co << 7.{{ it > 2 ?? break[ 555 ] ; it }} ; ... [ 0, 1, 2, 555, ]",
"(; (<< (. @ .co ) (each 7 { (; (?? (> it 2 ) { (break [ 555 ] ) } ) ) it } ) ) )",
"[ 0, 1, 2, 555, ]"
) ;

birds_script( "\
@.co << 7.{{ it < 3 ?? continue [ ] ; it }} ; ... [ 3, 4, 5, 6, ]",
"(; (<< (. @ .co ) (each 7 { (; (?? (< it 3 ) { (continue [  ] ) } ) ) it } ) ) )",
"[ 3, 4, 5, 6, ]"
) ;

birds_script( "\
@.co << 9.{{ it % 2 == 0 ?? continue [ ] ; it }} ; ... [ 1, 3, 5, 7, ]",
"(; (<< (. @ .co ) (each 9 { (; (?? (== (% it 2 ) 0 ) { (continue [  ] ) } ) ) it } ) ) )",
"[ 1, 3, 5, 7, ]"
) ;

</script><pre>

    スコープ '(', ')' でも ',' が意味を持ちます。
    複数の実行文の中から最後に積んだ値をひとつだけ返せます。

</pre><script>

birds_script( "\
boo :: foo :: woo :: 0 ;\n\
b : (\n\
    boo = 1 ;\n\
    foo = 2 ,   ... 注目（ここで積んでいます）\n\
    woo = 3 ;\n\
) ;\n\
\n\
@.co << b ;     ... b : 2",
"(; (:: boo (:: foo (:: woo 0 ) ) ) ) (; (: b (scope { (; (= boo 1 ) ) (, (= foo 2 ) ) (; (= woo 3 ) ) } ) ) ) (; (<< (. @ .co ) b ) )",
"2"
) ;


birds_script( "\
boo :: foo :: woo :: 0 ;\n\
b : (\n\
    boo = 1 ,\n\
    foo = 2 ,\n\
    woo = 3 ,   ... ３つ積んでもスコープから返るのは最後に積んだ１つだけです\n\
) ;\n\
\n\
@.co << b ;     ... b : 3",
"(; (:: boo (:: foo (:: woo 0 ) ) ) ) (; (: b (scope { (, (= boo 1 ) ) (, (= foo 2 ) ) (, (= woo 3 ) ) } ) ) ) (; (<< (. @ .co ) b ) )",
"3"
) ;

</script><pre>

-----------------------------------------------------------------------
■ range '..'   範囲を指定した list の表記

    range の表記は '..' です。 list の簡易表記です。

    1..2 は [ 1, 2, ] と等価です。
    3..6 は [ 3, 4, 5, 6, ] と等価です。
    9..5 は [ 9, 8, 7, 6, 5, ] と等価です。

</pre><script>

birds_script( "\
@.co << 1..2 << \"\\n\" ;     ... [ 1, 2, ]\n\
@.co << 3..6 << \"\\n\" ;     ... [ 3, 4, 5, 6, ]\n\
@.co << 9..5 << \"\\n\" ;     ... [ 9, 8, 7, 6, 5, ]\n\
@.co << 5..7.{{ it*2 }} ;  ... [ 10, 12, 14, ]",
"(; (<< (<< (. @ .co ) (range 1 2 ) ) '\n' ) ) (; (<< (<< (. @ .co ) (range 3 6 ) ) '\n' ) ) (; (<< (<< (. @ .co ) (range 9 5 ) ) '\n' ) ) (; (<< (. @ .co ) (each (range 5 7 ) { (* it 2 ) } ) ) )",
"[ 1, 2, ]\n[ 3, 4, 5, 6, ]\n[ 9, 8, 7, 6, 5, ]\n[ 10, 12, 14, ]"
) ;

birds_script( "\
a : 3 ; b : 5 ; \n\
@.co << a..b << \"\\n\" ;  ... [ 3, 4, 5, ]\n\
@.co << a..b.{{ it*2 }} ;  ... [ 6, 8, 10, ]",
"(; (: a 3 ) ) (; (: b 5 ) ) (; (<< (<< (. @ .co ) (range a b ) ) '\n' ) ) (; (<< (. @ .co ) (each (range a b ) { (* it 2 ) } ) ) )",
"[ 3, 4, 5, ]\n[ 6, 8, 10, ]"
) ;

birds_script( "\
@.co << (5..7).type ;  ... 型は list",
"(; (<< (. @ .co ) (. (scope { (range 5 7 ) } ) .type ) ) )",
"list"
) ;

</script><pre>

    整数 int 以外は指定できません。
    実行時エラーになります。

</pre><script>

birds_script( "\
@.co << 'a'..'c' ;         ... NG ... できてもいい気もする",
"(; (<< (. @ .co ) (range 'a' 'c' ) ) )",
"\nrun-time error: argument type is not int : literal.str"
) ;

birds_script( "\
a : 'a' ; c : 'c' ; \n\
@.co << a..c ;             ... NG",
"(; (: a 'a' ) ) (; (: c 'c' ) ) (; (<< (. @ .co ) (range a c ) ) )",
"\nrun-time error: argument type is not int : a.str"
) ;

</script><pre>

-----------------------------------------------------------------------
■ list と添え字

    list と添え字 [ ] について解説します。

    他の多くの言語と同様に a という配列の 3番目要素は０から数えるので a[2] と記述します。

</pre><script>

birds_script( "\
a : [ 1, 2, 3, 4, 5, ] ;\n\
@.co << a[2] << ', ' ;              ... 3 \n\
\n\
@.co << [ 1, 2, 3, 4, 5, ][ 2 ] ;   ... 3\n\
@.co << ', ' ;\n\
\n\
@.co << [ 1, 2, 3, 4, 5, ][ 9 ] ;   ... unmatch index.",
"(; (: a [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) ] ) ) (; (<< (<< (. @ .co ) (at a 2 ) ) ', ' ) ) (; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) ] 2 ) ) ) (; (<< (. @ .co ) ', ' ) ) (; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) ] 9 ) ) )",
"3, 3, \nexception: on_unmatch unmatch member-name.: .9"
) ;

</script><pre>

    で、BirdsScript では list の添え字に list が使えたりします。

</pre><script>

birds_script( "\
@.co << [ 1, 2, 3, 4, 5, ][ [ 1, 2, 3, ] ] ;    ... [ 2, 3, 4, ]\n\
@.co << \"\\n\" ;\n\
\n\
@.co << [ 1, 2, 3, 4, 5, ][ [ 3, 2, 1, ] ] ;    ... [ 4, 3, 2, ]\n\
@.co << \"\\n\" ;\n\
\n\
@.co << [ 1, 2, 3, 4, 5, ][ [ 9, ] ] ;  ... [  ] ... なんと！これはエラー unmatch index. にならないのですが、エラーにしたほうがいいかも。",
"(; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) ] [ (, 1 ) (, 2 ) (, 3 ) ] ) ) ) (; (<< (. @ .co ) '\n' ) ) (; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) ] [ (, 3 ) (, 2 ) (, 1 ) ] ) ) ) (; (<< (. @ .co ) '\n' ) ) (; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) ] [ (, 9 ) ] ) ) )",
"[ 2, 3, 4, ]\n[ 4, 3, 2, ]\n[ ]"
) ;

</script><pre>

    同様に簡易表記 range も記述できます。

</pre><script>

birds_script( "\
@.co << [ 1, 2, 3, 4, 5, ][ 1..3 ] ;    ... [ 2, 3, 4, ]\n\
@.co << \"\\n\" ;\n\
\n\
@.co << [ 1, 2, 3, 4, 5, ][ 3..1 ] ;    ... [ 4, 3, 2, ]",
"(; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) ] (range 1 3 ) ) ) ) (; (<< (. @ .co ) '\n' ) ) (; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) ] (range 3 1 ) ) ) )",
"[ 2, 3, 4, ]\n[ 4, 3, 2, ]"
) ;

</script><pre>

    さらに unmatch も指定してみる。 unmatch は予約語です。

</pre><script>

birds_script( "\
@.co << [ 1, 2, 3, 4, 5, unmatch:55, ][ 9 ] ;  ... 55\n\
@.co << \"\\n\" ;\n\
\n\
@.co << [ 1, 2, 3, 4, 5, unmatch:55, ][ [ 1, 9, 2, 8, 3, 7, ] ] ;    ... [ 2, 55, 3, 55, 4, 55, ]\n\
@.co << \"\\n\" ;\n\
\n\
@.co << [ 1, 2, 3, 4, 5, unmatch:55, ][ 9..11 ] ;    ... [ 55, 55, 55, ]",
"(; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) (, (: unmatch 55 ) ) ] 9 ) ) ) (; (<< (. @ .co ) '\n' ) ) (; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) (, (: unmatch 55 ) ) ] [ (, 1 ) (, 9 ) (, 2 ) (, 8 ) (, 3 ) (, 7 ) ] ) ) ) (; (<< (. @ .co ) '\n' ) ) (; (<< (. @ .co ) (at [ (, 1 ) (, 2 ) (, 3 ) (, 4 ) (, 5 ) (, (: unmatch 55 ) ) ] (range 9 11 ) ) ) )",
"55\n[ 2, 55, 3, 55, 4, 55, ]\n[ 55, 55, 55, ]"
) ;

</script><pre>

------------------------------------------------

  ここで休憩の区切りを入れます。

  list の以下の３点に関して、BirdsScriptの特徴（基本）になりますので、よく確認して次へお進みください。

  ・list の宣言 '[', ']'
  ・list と loop文, each文, break, continue の関係
  ・list に積む ',' / 積まない ';' 区切り文字の使い方

  次は、いよいよ関数の宣言と、list の関係にせまります。
  <a href="http://birdsscript.com/BirdsScript02.html">http://birdsscript.com/BirdsScript02.html</a>

</pre>

<script>
if ( c_NG === 0 && c_max > 0 )
    document.write( '<div style="background-color:#99D;padding:10px;">'+(c_max-c_NG)+'/'+c_max+' OK!</div>' ) ;
else
    document.write( '<div style="background-color:#D55;padding:10px;">'+(c_max-c_NG)+'/'+c_max+' NG!</div>' ) ;
</script>

<!-- <a href="https://twitter.com/share" class="twitter-share-button" data-text="BirdsScript" data-lang="ja" data-size="large" data-count="none" data-hashtags="BirdsScript">ツイート</a><script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script><div class="g-plusone" data-annotation="none"></div><script type="text/javascript">window.___gcfg = {lang: 'ja'};(function() {var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;po.src = 'https://apis.google.com/js/plusone.js'; var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);})();</script><a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="standard-noballoon" data-hatena-bookmark-lang="ja" title="このエントリーをはてなブックマークに追加"><img src="http://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="http://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script> -->

</body>
</html>
